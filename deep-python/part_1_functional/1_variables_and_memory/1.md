# Python Variables, References & Memory Management

## Memory & Variables

| Object   | Memory Address |
| -------- | -------------- |
| Object 1 | 0x1000         |
| Object 1 | 0x1001         |
| Object 1 | 0x1002         |
| Object 2 | 0x1003         |
| Object 2 | 0x1004         |

üëâ In Python, variables are just **references** (names) that point to objects stored in memory.

You can find the memory address of an object with `id()`:

```python
var = "hello world"
print(hex(id(var)))
```

---

## Reference Counting

- Every object in Python has a **reference count**.
- If an object has ‚â•1 references, Python keeps it alive.
- If the reference count drops to **0**, Python deletes it (garbage collection).

### Checking Reference Count

```python
import sys, ctypes

my_name = "name"

ref_count = lambda obj: ctypes.c_long.from_address(id(obj)).value

print(f"sys.getrefcount: {sys.getrefcount(my_name)}")
print(f"ctypes from_address: {ref_count(my_name)}")
```

‚ö†Ô∏è Note: `sys.getrefcount()` is usually **one higher** because the function call itself creates a temporary reference.

---

## Garbage Collection

Reference counting **cannot handle circular references**.

Example of a cycle:

```python
class A:
    def __init__(self):
        self.b = B(self)
        print(f"A: self={hex(id(self))}, b={hex(id(self.b))}")

class B:
    def __init__(self, a):
        self.a = a
        print(f"B: self={hex(id(self))}, a={hex(id(self.a))}")
```

Python‚Äôs **garbage collector (gc module)** can detect and break such cycles.

---

## Variable Reassignment

Rebinding a variable makes it point to a new object:

```python
my_var = 1234    # my_var -> object at 0x001
my_var = my_var + 1
# now my_var -> object at another address
```

Object reuse example:

```python
a = 10
b = 10

print(a is b)   # True (same interned object)
print(hex(id(a)), hex(id(b)))
```

---

## Mutability

- **Mutable objects** ‚Üí can change internal state
  (lists, sets, dicts, user-defined classes).

- **Immutable objects** ‚Üí cannot be changed after creation
  (int, float, bool, str, tuple, frozenset, user-defined immutable classes).

Example:

```python
a = [1, 2, 3]
b = a
a.append(4)
print(b)  # [1, 2, 3, 4] ‚Üí both reference same list
```

---

## Shared References

- **Immutable objects** may be shared safely:

  ```python
  a = 10
  b = a
  a = 12
  print(b)  # still 10
  ```

- **Mutable objects** cause side effects if shared:

  ```python
  a = [1, 2, 3]
  b = a
  a.append(4)
  print(b)  # [1, 2, 3, 4]
  ```

---

## Variable Equality

- **Identity (`is`, `is not`)** ‚Üí compare memory addresses.
- **Equality (`==`, `!=`)** ‚Üí compare object values.

```python
a = 10
b = 10.0
print(a is b)   # False (different objects)
print(a == b)   # True  (same value)
```

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a is b)   # False
print(a == b)   # True
```

Special case:

```python
a = None
b = None
print(a is b)   # True (singleton None object)
```

---

## Interning

- CPython pre-loads small integers `[-5, 256]`.

  ```python
  a = 257
  b = 257
  print(a is b)  # False (not guaranteed to reuse)
  ```

- Some strings are also **interned** automatically.

- You can force interning:

  ```python
  import sys
  s1 = sys.intern("hello world")
  s2 = sys.intern("hello world")
  print(s1 is s2)  # True
  ```

---

## Everything is an Object

- Functions, classes, numbers, even `None` are all objects.
- Functions are instances of `function`.
- Classes are instances of `class`.

```python
def my_func():
    pass

print(type(my_func))      # <class 'function'>
print(type(int))          # <class 'type'>
```

---

## Peephole Optimizations

Python performs some **compile-time optimizations** before execution.
This is called **peephole optimization**.

### Examples

1. **Constant Folding**
   Expressions with constants are precomputed:

   ```python
   x = 2 * 10    # compiled as x = 20
   y = "ab" "cd" # compiled as y = "abcd"
   ```

2. **Immutable Tuple Reuse**
   Small constant tuples are cached:

   ```python
   x = (1, 2, 3)
   y = (1, 2, 3)
   print(x is y)  # may be True due to caching
   ```

3. **Dead Code Elimination**
   Blocks that will never run are removed:

   ```python
   if False:
       print("Never runs")  # eliminated
   ```

‚ö†Ô∏è These optimizations are **implementation details** of CPython.
They may vary between versions.
