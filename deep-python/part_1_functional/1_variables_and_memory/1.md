# Variables and Memory

| memory   | address |
| -------- | ------- |
| Object 1 | 0x1000  |
| Object 1 | 0x1001  |
| Object 1 | 0x1002  |
| Object 2 | 0x1003  |
| Object 2 | 0x1004  |

> In Python, you can find the memory address referenced by a variable using the `id()` function.

```python
var = "hello world"
print(hex(id(var)))
```

## Reference Counting

> If an object has one or more references to it, Python will keep it. However, if its reference count drops to zero, Python's garbage collector will delete it.

You can see the reference count to an object by using `getrefcount()` from the `sys` module or `from_address()` from the `ctypes` library.

```python
import sys
import ctypes

my_name = "name"
ref_count = lambda address: ctypes.c_long.from_address(id(address)).value

print(f"Reference count of value {my_name!r} is {sys.getrefcount(my_name)}.")
print(f"Reference count of value {my_name!r} is {ref_count(my_name)}.")
```

## Garbage Collection

> Reference counting won't solve the problem of circular references, so we need a garbage collector.

```python
class A:
    def __init__(self):
        self.b = B(self)
        print(f"A: self: {hex(id(self))}, b: {hex(id(self.b))}")

class B:
    def __init__(self, a):
        self.a = a
        print(f"B: self: {hex(id(self))}, a: {hex(id(self.a))}")
```

## Variable Reassignment

```python
my_var = 1234
# my_var -> 0X001

my_var = my_var + 1
# my_var -> 0X1234 (other memory address)

a = 10
b = 10

print(a is b) # --> True
print(f"id(a)= {hex(id(a))}\nid(b)= {hex(id(b))}") # -> prints the same memory address for both objects
```

## Object Mutability

> When an object is mutated, the internal state of the object changes.

**Mutable**: An object whose internal state can be changed (add, remove, change).

- Lists
- Sets
- Dictionaries
- User-Defined Classes

**Immutable**: An object whose internal state cannot be changed (add, remove, change).

- Numbers (int, float, Boolean, etc.)
- Strings
- Tuples
- Frozen Sets
- User-Defined Classes

**Immutable objects are safe from unintended side effects.**

## Shared Reference and Mutability

> Shared reference: Two variables share the same memory address.

With mutable objects, Python never creates shared references, but with immutable objects, we can have shared references.

```python
a = 10 # a -> 10
b = a  # b -> 10
a = 12
print(b) ## prints 10
```

```python
a = [1, 2, 3]
b = a
a.append(4)
print(b) ## prints [1, 2, 3, 4]
```

Simply mutable objects are created in memory once and you can point any variable to them, but you cannot change them.

## Variable Equality

**Memory address**: `is` `is not` `not` (identity operator)

**Object state(data)**: `==` `!=` (equality operator)

```python
a = 10
b = 10.0
print(f"a is b -> {a is b}\na == b -> {a == b}")
## prints false, true
```

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(f"a is b -> {a is b}\na == b -> {a == b}")

## prints false, true
```

```python
a = None
b = None
c = None
# a is None, a is b, b is c
```

**Interning**: Reusing objects on-demand.

> At startup, Python (CPython) pre-loads (caches) a global list of integers in the range [-5, 256] (**Singletons**).

```python
a = 257
b = 257
print(a is b) ## prints False
```

> Python may still reuse integers beyond 256, but it's not guaranteed. [WTF?]

## Everything Is an Object

Even functions are instances of class `function`.
The class itself is an instance of class `class`.

```python
def my_func():
    ...
```

`my_func` -> name of the function  
`my_func()` -> invoke the function

## String Interning

> Some strings are also interned, but not all!

You can force strings to be interned by using `sys.intern()` method.
