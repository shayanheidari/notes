# Protocols

## Protocol Properties

> What to take int account when designing a protocol?

**What is a protocol?**

- A system that allows two parties to communicate
- A protocol is designed with a set of properties
- Depending on the purpose of the protocol
- TCP, UDP, HTTP, gRPC, FTP

## Protocol properties

- Data format
  - Text based (plain text , JSON , XML)
  - Binary (protobuf, RESP, http2, http3)
- Transfer mode
  - Message based(UDP, HTTP)
  - Steam (of bytes) (TCP, WebRTC)
- Addressing system
  - DNS name, IP, MAC
- Directionality
  - Bidirectional(TCP)
  - Unidirectional(HTTP)
  - Full/Half duplex
- State
  - Stateful(TCP, gRPC, apache thrift)
  - Stateless(UDP, HTTP)
- Routing
  - Proxies, Gateways
- Flow & Congestion control
  - TCP(Flow & Congestion)
  - UDP(No control)
- Error management
  - Error code
  - Retries and timeouts

## OSI Model

> Open System Interconnection Model

**Why do we need a communication model?**

- Agnostic applications
  - Without a standard model, your application must have knowledge of the underlying network medium
  - Imagine if you have to author different version of your apps so that it works on wifi vs ethernet vs LTE vs fiber
- Network Equipment Management
  - Without a standard mode, upgrading network equipments becomes difficult
- Decoupled Innovation
  - Innovation can be done in each layer separately without affecting the rest of the models

**What is the OSI Model?**

- Layer 7 ➡ [***Application***] - HTTP/FTP/gRPC
  > ==Sender [->]== POST request with JSON data to HTTPS server
  > ==Receiver [<-]== Application understands the JSON POST request and your express JSON or apache request recieves event is triggered
- Layer 6 ➡ [***Presentation***] - Encoding, Serialization
  > ==Sender [->]== Serialize JSON to flat byte strings
  > ==Receiver [<-]== Deserialize flat byte strings back to JSON for the app to consume
- Layer 5 ➡ [***Session***] - Connection establishment, TLS
  > ==Sender [->]== Request to establish TCP connection/TLS
  > ==Receiver [<-]== The connection session is established of identified
  > ==Receiver [<-]== We only arrive at this layer when necessary (Three way handshake is done)
- Layer 4 ➡ [***Transport***] - UDP/TCP
  > ==Sender [->]== Sends SYN request target port 443
  > ==Receiver [<-]== The IP packets from layer 3 are assembled into TCP segments
  > ==Receiver [<-]== Deals with congestion control/flow control/retransmission in case of TCP
  > ==Receiver [<-]== If Segment is SYN we don't need to go further into more layers as we are still processing the connection request
- Layer 3 ➡ [***Network***] - IP
  > ==Sender [->]== SYN is placed an IP packet(s) and adds the source/dest IPs
  > ==Receiver [<-]== The frames from layer 2 are assembled into IP packet
- Layer 2 ➡ [***Data link***] - Frames, Mac address Ethernet
  > ==Sender [->]== Each packet goes into a single frame and adds the source/dest MAC addresses
  > ==Receiver [<-]== The bits from layer 1 is assembled into frames
- Layer 1 ➡ [***Physical***] - electric signals, fiber or radio waves
  > ==Sender [->]== Each frame becomes string of bits which converted into either a radio signal(wifi), electric signal(ethernet), or light(fiber)
  > ==Receiver [<-]== Radio, electric or light is recieved and converted into digital bits

---

---

## Internet Protocol

**IP Address**

- Layer 3 property
- Can be set automatically or statically
- Network and host portion
- 4 bytes in IPv4 - 32 bit

---

**Network vs Host**

- a.b.c.d/x (a.b.c.d are integers) x is the network bits and remains are host -> [192.168.254.0/24]
- the first 24 bits(3bytes) are network the rest 8 are for host
- this means we can have 2^24 networks and each 2^8 hosts
- Also called a subnet

---

**Subnet Mask**

- 192.168.4.0/24 is also called a subnet
- The subnet has a mask 255.255.255.0
- Subnet mask is used to determine whether an IP is in the same subnet

---

**Default Gateway**

- Most networks consist of hosts and a Default Gateway
- When host A want to talk to B directly if both are in the same subnet
- Otherwise A sends it to someone who might know, the gateway
- The Gateway has an IP Address and each host should know its gateway

---

### The IP Packet

**IP Packet**

- The IP Packet has headers and data sections
- IP Packet header is 20 bytes (can go up to 60 bytes if options are enabled)
- Data section can go up to 65536

---

### ICMP (Internet Control Message Protocol)

**ICMP**

- Stands for internet Control Message Protocol
- Designed for informational messages
  - Host Unreachable, port unreachable, fragmentation needed
  - Packet expired (infinite loop in routers)
- Uses IP directly
- PING and traceroute use it
- Doesn't require listeners or ports to be opened
- Some firewalls block ICMP for security reasons
- that is why PING might not work n those cases
- Disabling ICMP also can cause real damage with connection establishment
- [TCP Blackhole]

---

**TraceRoute**

`traceroute` command in linux

- Can you identify the entire path your IP Packet takes?
- Clever use of TTL
- increment the TTL in each ICMP hop until it reaches the destination
- Doesn't always work as path changes and ICMP might be blocked

---

## UDP (User Datagram Protocol)

- Layer 4 protocol
- Ability to address processes in a host using ports
- Simple protocol to send and receive data
- Prior communication not required (double edge sword)
- Stateless no knowledge is stored on the host
- 8 byte header Datagram

### UDP Use Cases

- Video streaming
- VPN
- DNS
- WebRTC

### Multiplexing and demultiplexing

- IP target hosts only
- Hosts run many apps each with different requirements
- Ports now identify the 'app' or 'process'
- Sender Multiplexes all its app into UDP
- Receiver demultiplex UDP datagrams to each app

### UDP Datagram

- UDP Header is 8 bytes only (IPv4)
- datagram slides into and IP packet as "data"
- Port are 16 bit (0 to 65535)

### UDP Pros

- Simple protocol
- Header size is small so datagrams are small
- Uses less bandwidth
- Stateless
- Consumes less memory (no state stored in the server/client)
- Low latency - no handshake, order, retransmission or guaranteed delivery

### UDP Cons

- No Acknowledgement
- No guaranteed delivery
- Connection-less - anyone can send data without prior knowledge
- No flow control
- No congestion control
- No ordered packets
- Security - can be easily spoofed

## TCP (Transmission Control Protocol)

- Layer 4 protocol
- Ability to address processes in a host using ports
- "controls" the transmission unlike UDP which is a firehouse
- Connection
- Requires handshake
- 20 bytes headers Segment (can go to 60)
- Stateful

### TCP Use cases

- Reliable communication
- Remote shell
- Database Connection
- Web Communications
- Any Bidirectional communication

### TCP Connection

- Connection is a Layer 5 (session)
- Connection is an agreement between client and server
- Must create a connection to send data
- Connection is identified by 4 properties
  - SourceIP-SourcePort
  - DestinaotionIP-DestinationPort
- Can't send data outside of a connection
- Sometimes called socket or file descriptor
- Requires a 3-way TCP handshake
- segments are sequenced and ordered
- segments are acknowledged
- lost segments are retransmitted

### Multiplexing and demultiplexing

- IP target hosts only
- Hosts run many apps each with different requirements
- Ports now identify the 'app' or 'process'
- Sender multiplexes all its apps into TCP connections
- Receiver demultiplex TCP segments to each app based on connection pairs

### UCP segment

- TCP segment header is 20 bytes and can go up to 60 bytes
- TCP segments slides into an IP packet as "data"
- Port are 16 bit (0 to 65535)
- Sequences, Achnowledgement, flow control and more
